$ template make_analysis()

$ // Generate the analysis.mli file 
module type ANALYSIS = sig
(* This file was generated by SableCC (http://www.sablecc.org/). *)

open Nodes

type visitor = {
    override : node -> node -> node;
       enter : node -> node -> visitor;
       leave : node -> node -> node -> visitor -> node;
       start : unit -> visitor;
      finish : node -> unit;
  }

val visit_edge : visitor -> Nodes.node -> Nodes.node -> Nodes.node
val rev_visit_edge : visitor -> Nodes.node -> Nodes.node -> Nodes.node

val dummy_visitor : visitor

end

module Analysis = struct

(* This file was generated by SableCC (http://www.sablecc.org/). *)

open Nodes

type visitor = {
    override : node -> node -> node;
       enter : node -> node -> visitor;
       leave : node -> node -> node -> visitor -> node;
       start : unit -> visitor;
      finish : node -> unit;
  }

let rec dummy_visitor = {
  override = (fun parent n -> n);
     enter = (fun parent n -> dummy_visitor);
     leave = (fun parent old_child child v -> child);
     start = (fun () -> dummy_visitor);
    finish = (fun n -> ());
}

exception Stop_Traversal of node

let rec visit_edge visitor parent child =
  try let n = visitor.override parent child in
  let v_ = visitor.enter parent child in
  let nn = visit_children v_ child in
  v_.leave parent child nn v_
  with Stop_Traversal n -> n
and visit_children v c = 
  match c with
  | Start (${/parser/prods/prod/@ename} (${/parser/prods/prod/alt/@ename} a), t) -> 
      let v1 = visit_edge v c (P (${/parser/prods/prod/@ename} (${/parser/prods/prod/alt/@ename} a))) in
      (match v1 with (P v2) ->
        Start (v2, t) | _ -> failwith "type error")
$  foreach {//prod}
$    set pname = @name
$    foreach {alt}
  | P ${../@ename} @ename a ->
$      set an = @name
$      if {count(../alt) != 1}
$      set an = {concat(@name, '_', $pname)}
$      end if
$      foreach {elem}
$        set ann = {concat($an, '_', @name)}
      let v${position()} = [-if {@is_list}-](List.map (visit_edge v c) (List.map (function x -> [-if {@is_token}-]T x[-else-]P (@etype x)[-end-]) a.$ann))[-else-](match a.$ann with None -> Nodes.Null_Node | Some aa -> (visit_edge v c [-if {@is_token}-](T aa)[-else-]((function x -> P (@etype x)) aa)[-end if-]))[-end if-] in
$      end foreach
        P (${../@ename} (@ename (a_$an
$      foreach {elem}
              v${position()}
$      end
          )))
$    end
$  end
  | _ -> c

let rec rev_visit_edge visitor parent child =
  try let n = visitor.override parent child in
  let v_ = visitor.enter parent child in
  let nn = rev_visit_children v_ child in
  v_.leave parent child nn v_
  with Stop_Traversal n -> n
and rev_visit_children v c = 
  match c with
  | Start (${/parser/prods/prod/@ename} (${/parser/prods/prod/alt/@ename} a), t) -> 
      let v1 = rev_visit_edge v c (P (${/parser/prods/prod/@ename} (${/parser/prods/prod/alt/@ename} a))) in
      (match v1 with (P v2) ->
        Start (v2, t) | _ -> failwith "type error")
$  foreach {//prod}
$    set pname = @name
$    foreach {alt}
  | P ${../@ename} @ename a ->
$      set an = @name
$      if {count(../alt) != 1}
$      set an = {concat(@name, '_', $pname)}
$      end if
$      foreach {reverse(elem)}
$        set ann = {concat($an, '_', @name)}
      let v${position()} = [-if {@is_list}-](List.map (rev_visit_edge v c) (List.map (function x -> [-if {@is_token}-]T x[-else-]P (@etype x)[-end-]) (List.rev a.$ann)))[-else-](match a.$ann with None -> Nodes.Null_Node | Some aa -> (rev_visit_edge v c [-if {@is_token}-](T aa)[-else-]((function x -> P (@etype x)) aa)[-end if-]))[-end if-] in
$      end foreach
      P (${../@ename} (@ename (a_$an
$      foreach {elem}
              v${count(../elem)-position()+1}
$      end
          )))
$    end
$  end
  | _ -> c

end

$ end template

