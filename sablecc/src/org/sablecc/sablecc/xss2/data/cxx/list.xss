$ template make_list()
$
$ // Generate the list.cpp file 
$ output $basedir + '/list.cpp'
/* This file was generated by SableCC (http://www.sablecc.org/). */

#include "node.h"
#include "list.h"

void $namespace::_List_helper::insert (_GenericNode *owner, list_t& guts, list_t::iterator pos, Node node)
{
  if ( !node ) return; // Should we throw something instead?

  if ( owner ) {
      if ( node.parent() ) node.parent().removeChild(node);
      node.parent(owner);
  }

  guts.insert (pos, node);
}

bool $namespace::_List_helper::replace (_GenericNode *owner, list_t& guts, Node node, Node new_node)
{
  if ( node == new_node ) return false; // Should we throw something instead?
  if ( !new_node ) return erase (owner, guts, node);

  for ( list_t::iterator it = guts.begin(); it != guts.end(); it++ ) {
      if ( *it == node ) {
          if (owner) {
              (*it).parent(0);
              if ( new_node.parent() ) new_node.parent().removeChild(new_node);
              new_node.parent(owner);
          }
          *it = new_node;
          return true;
      }
  }

  return false;
}

void $namespace::_List_helper::assign (_GenericNode *owner, list_t& guts,
    const _GenericNode *fo, const list_t& fg)
{
  _GenericNode *from_owner = const_cast<_GenericNode *>(fo);
  list_t from_guts = const_cast<list_t&>(fg);

  if ( &guts == &from_guts ) return;  // safety

  _List_helper::erase (owner, guts, guts.begin(), guts.end());
  for ( list_t::iterator it = from_guts.begin(); it != from_guts.end(); it++ ) {
      Node n = *it;
      guts.push_back(n);

      if ( owner ) {
          if ( !from_owner && n.parent() )
              n.parent().removeChild (n);

          n.parent (owner);

          if ( from_owner ) {
              it = from_guts.erase(it);
              continue;
          }
      }
  }
}

bool $namespace::_List_helper::erase (_GenericNode *owner, list_t& guts, Node node)
{
  for ( list_t::iterator it = guts.begin(); it != guts.end(); it++ ) {
      if ( *it == node ) {
          if (owner) (*it).parent(0);
          guts.erase(it);
          return true;
      }
  }

  return false;
}

$namespace::_List_helper::list_t::iterator $namespace::_List_helper::erase (_GenericNode *owner, list_t& guts, list_t::iterator begin, list_t::iterator end)
{
  if ( owner ) {
      for ( list_t::iterator it = begin; it != end; it++ )
          (*it).parent(0);
  }

  return guts.erase (begin, end);
}

void $namespace::_List_helper::apply (list_t& guts, Analysis& analysis)
{
  list_t l = guts;
  for ( list_t::iterator it = l.begin(); it != l.end(); it++ )
      (*it).apply (analysis);
}

void $namespace::_List_helper::reverse_apply (list_t& guts, Analysis& analysis)
{
  list_t l = guts;
  for ( list_t::reverse_iterator it = l.rbegin(); it != l.rend(); it++ )
      (*it).apply (analysis);
}
$ end output

$ // Generate the list.h file 
$ output $incdir + '/list.h'
/* This file was generated by SableCC (http://www.sablecc.org/). */

#ifndef __${$namespace}__list_hh__
#define __${$namespace}__list_hh__

#include <vector>
#include <list>
#include <string>

namespace $namespace {

class Analysis;

class _List_helper {
  typedef std::list<Node> list_t;

  static void insert (_GenericNode *owner, list_t& guts, list_t::iterator pos, Node node);
  static list_t::iterator erase (_GenericNode *owner, list_t& guts, list_t::iterator begin, list_t::iterator end);
  static bool erase (_GenericNode *owner, list_t& guts, Node node);
  static bool replace (_GenericNode *owner, list_t& guts, Node node, Node new_node);
  static void assign (_GenericNode *owner, list_t& guts, const _GenericNode *fowner, const list_t& from);
  static void apply (list_t& guts, Analysis& analysis);
  static void reverse_apply (list_t& guts, Analysis& analysis);

  template <typename U> friend class List;
  friend class _GenericNode;
};

template<typename T>
class List
{
  typedef typename _List_helper::list_t list_t;

public:
  class iterator {
    iterator(list_t::iterator it) : it(it) { }
    list_t::iterator it;
    friend class List<T>;

  public:
    inline T* operator->() { return (T *)it.operator->(); }
    inline T operator* () { return reinterpret_cast<T&>(*it); }

    inline iterator operator++ (int) { iterator rit = *this; it++; return rit; }
    inline iterator operator-- (int) { iterator rit = *this; it--; return rit;}
    inline iterator& operator++ () { ++it; return *this; }
    inline iterator& operator-- () { --it; return *this;}

    friend inline bool operator== (const iterator& l, const iterator& r) { return l.it == r.it; }
    friend inline bool operator!= (const iterator& l, const iterator& r) { return l.it != r.it; }
  };

  inline List () : owner(0) { }
  inline List (const List<T>& l) : owner (0) { _List_helper::assign (owner, list, l.owner, l.list); }
  inline ~List () { }

  inline List<T>& operator= (const List<T>& l) { _List_helper::assign (owner, list, l.owner, l.list); return *this; }

  inline iterator begin() { return list.begin(); }
  inline iterator end() { return list.end(); }

  inline void push_back (T node) { insert (end(), node); }
  inline void push_front (T node) { insert (begin(), node); }

  inline T front () { return reinterpret_cast<T&>(list.front()); }
  inline T back () { return reinterpret_cast<T&>(list.back()); }

  inline void insert (iterator pos, T node) { _List_helper::insert (owner, list, pos.it, node); }

  inline iterator erase (iterator first, iterator last) { return _List_helper::erase (owner, list, first.it, last.it); }

  inline iterator erase (iterator pos)
  { iterator n = pos; ++n; return erase(pos, n); }

  inline bool erase (T node) { return _List_helper::erase (owner, list, node); }
  inline bool replace (T old_node, T new_node) { return _List_helper::replace(owner, list, old_node, new_node); }

  inline void clear () { _List_helper::erase(owner, list, list.begin(), list.end()); }

  inline bool empty () const { return list.empty(); }
  inline size_t size () const { return list.size(); }

  inline void apply (Analysis& analysis) { _List_helper::apply (list, analysis); }
  inline void reverse_apply (Analysis& analysis) { _List_helper::reverse_apply (list, analysis); }

private:
  _GenericNode *owner;
  list_t list;

  inline void setOwner (_GenericNode *o) { owner = o; }

  friend class _GenericNode;
  friend class Node;
};

} // namespace $namespace {

#endif // !__${$namespace}__list_hh__
$ end output

$ end template

