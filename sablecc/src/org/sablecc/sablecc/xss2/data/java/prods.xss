$ template make_prods()
$
$ // the first production name that goes into Start
$ set baseprod = {//prod/@ename}

$ // generate all production files
$ foreach {//prod}
$   output $basedir + '/node/' + @ename + '.java'
/* This file was generated by SableCC (http://www.sablecc.org/). */

package $package.node;

public abstract class @ename extends Node
{
}
$   end
$ end

$ // generate all alternative files
$ foreach {//alt}
$   output $basedir + '/node/' + @ename + '.java'
/* This file was generated by SableCC (http://www.sablecc.org/). */

package $package.node;

import java.util.*;
import $package.analysis.*;

public final class @ename extends ${../@ename}
{
$ // define subnodes
$ foreach {elem}
$   if @is_list
    private final LinkedList _@{name}_ = new TypedLinkedList(new @{ename}_Cast());
$   else
    private @etype _@{name}_;
$   end
$ end

$ // define default empty constructor
$ if {elem}
    public @ename ()
    {
    }
$ end

$ // define constructor
    public @ename (
$ foreach {elem}
$   if {@is_list}
            List _@{name}_[-sep ','-]
$   else
            @etype _@{name}_[-sep ','-]
$   end
$ end
    )
    {
$ foreach {elem}
$   if @is_list
        this._@{name}_.clear();
        this._@{name}_.addAll(_@{name}_);
$   else
        set@ename (_@{name}_);
$   end
$ end
    }

$ // define clone()
    public Object clone()
    {
        return new @ename (
$ foreach {elem}
$   if @is_list
            cloneList (_@{name}_)[-sep ','-]
$   else
            (@etype)cloneNode (_@{name}_)[-sep ','-]
$   end
$ end
        );
    }

$ // define apply()
    public void apply(Switch sw)
    {
        ((Analysis) sw).case@ename(this);
    }

$ // define accessors
$ foreach {elem}
$   if @is_list
    public LinkedList get@ename ()
    {
        return _@{name}_;
    }

    public void set@ename (List list)
    {
        _@{name}_.clear();
        _@{name}_.addAll(list);
    }
$   else
    public @etype get@ename ()
    {
        return _@{name}_;
    }

    public void set@ename (@etype node)
    {
        if(_@{name}_ != null)
        {
            _@{name}_.parent(null);
        }

        if(node != null)
        {
            if(node.parent() != null)
            {
                node.parent().removeChild(node);
            }

            node.parent(this);
        }

        _@{name}_ = node;
    }
$   end
$ end foreach

$ // define toString()
    public String toString()
    {
        return ""
$ foreach {elem}
            + toString (_@{name}_)
$ end
        ;
    }

$ // define removeChild()
    void removeChild(Node child)
    {
$ foreach {elem}
$   if @is_list
        if ( _@{name}_.remove(child))
        {
            return;
        }
$   else
        if ( _@{name}_ == child )
        {
            _@{name}_ = null;
            return;
        }
$   end
$ end
    }

$ // define replaceChild()
    void replaceChild(Node oldChild, Node newChild)
    {
$ foreach {elem}
$   if @is_list
        for(ListIterator i = _@{name}_.listIterator(); i.hasNext();)
        {
            if(i.next() == oldChild)
            {
                if(newChild != null)
                {
                    i.set(newChild);
                    oldChild.parent(null);
                    return;
                }

                i.remove();
                oldChild.parent(null);
                return;
            }
        }
$   else
        if ( _@{name}_ == oldChild )
        {
            set@ename ((@etype) newChild);
            return;
        }
$   end
$ end foreach
    }

$ //define cast inner classes for any list elements
$ foreach {elem[@is_list]}
    private class @{ename}_Cast implements Cast
    {
        public Object cast(Object o)
        {
            @etype node = (@etype) o;

            if((node.parent() != null) &&
                (node.parent() != ${../@ename}.this))
            {
                node.parent().removeChild(node);
            }

            if((node.parent() == null) ||
                (node.parent() != ${../@ename}.this))
            {
                node.parent(${../@ename}.this);
            }

            return node;
        }
    }
$ end foreach
}
$   end output
$ end foreach

$ // generate node/Start.java
$   output $basedir + '/node/Start.java'
/* This file was generated by SableCC (http://www.sablecc.org/). */

package $package.node;

import $package.analysis.*;

public final class Start extends Node
{
    private $baseprod _base_;
    private EOF _eof_;

    public Start()
    {
    }

    public Start(
        $baseprod _base_,
        EOF _eof_)
    {
        set$baseprod(_base_);
        setEOF(_eof_);
    }

    public Object clone()
    {
        return new Start(
            ($baseprod) cloneNode(_base_),
            (EOF) cloneNode(_eof_));
    }

    public void apply(Switch sw)
    {
        ((Analysis) sw).caseStart(this);
    }

    public $baseprod get$baseprod()
    {
        return _base_;
    }
    public void set$baseprod($baseprod node)
    {
        if(_base_ != null)
        {
            _base_.parent(null);
        }

        if(node != null)
        {
            if(node.parent() != null)
            {
                node.parent().removeChild(node);
            }

            node.parent(this);
        }

        _base_ = node;
    }

    public EOF getEOF()
    {
        return _eof_;
    }
    public void setEOF(EOF node)
    {
        if(_eof_ != null)
        {
            _eof_.parent(null);
        }

        if(node != null)
        {
            if(node.parent() != null)
            {
                node.parent().removeChild(node);
            }

            node.parent(this);
        }

        _eof_ = node;
    }

    void removeChild(Node child)
    {
        if(_base_ == child)
        {
            _base_ = null;
            return;
        }

        if(_eof_ == child)
        {
            _eof_ = null;
            return;
        }
    }
    void replaceChild(Node oldChild, Node newChild)
    {
        if(_base_ == oldChild)
        {
            set$baseprod(($baseprod) newChild);
            return;
        }

        if(_eof_ == oldChild)
        {
            setEOF((EOF) newChild);
            return;
        }
    }

    public String toString()
    {
        return "" +
            toString(_base_) +
            toString(_eof_);
    }
}
$   end output
$ end template
