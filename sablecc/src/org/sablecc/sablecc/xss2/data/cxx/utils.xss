$ template make_utils()
$
$ // Generate the test_lexer.cpp file 
$ output $basedir + '/test_lexer.cpp'
/* This file was generated by SableCC (http://www.sablecc.org/). */

#include "node.h"
#include "token.h"
#include "lexer.h"

using namespace std;
using namespace $namespace;

int main ()
{
  try {
      Lexer l(new StreamReader (cin.rdbuf()), true);

      while (1) {
          Token token = l.next();
          cout << "Read token '" << token.type_name() << "', getText = [" << token.getText() << "]" << endl;
          if ( token.is<TEOF>() ) break;
      }
  } catch (const LexerException& e) {
      cerr << "Caught lexer exception: " << e.getMessage() << endl;
  } catch (const Exception& e) {
      cerr << "Caught general exception: " << e.getMessage() << endl;
  } catch (...) {
      cerr << "Caught unspecified exception!!!" << endl;
  }

  return 0;
}
$ end output

$ // Generate the test_parser.cpp file 
$ output $basedir + '/test_parser.cpp'
/* This file was generated by SableCC (http://www.sablecc.org/). */

#include <iostream>
#include <stack>
#include <sstream>

#include "node.h"
#include "token.h"
#include "lexer.h"
#include "list.h"
#include "prod.h"
#include "parser.h"
#include "analysis.h"

using namespace std;
using namespace $namespace;

#ifdef USE_GTK

#include <gtk/gtk.h>

class GtkPrinter : public DepthFirstAdapter {
public:
  // End of tree, display it
  void inStart (Start node)
  {
    GtkWidget *tree = gtk_tree_new();
    gtk_widget_show(tree);
    stack.push(tree);
  }

  void outStart (Start node)
  {
    GtkWidget *window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
    gtk_signal_connect (GTK_OBJECT(window), "delete_event",
                        GTK_SIGNAL_FUNC (gtk_main_quit), NULL);
//    gtk_container_set_border_width (GTK_CONTAINER(window), 0);

    GtkWidget *scrolled_win = gtk_scrolled_window_new (NULL, NULL);
    gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolled_win),
                                    GTK_POLICY_AUTOMATIC,
                                    GTK_POLICY_AUTOMATIC);
    gtk_widget_set_usize (scrolled_win, 200, 200);
    gtk_container_add (GTK_CONTAINER(window), scrolled_win);
    gtk_widget_show (scrolled_win);

    GtkWidget *tree = stack.top();

    gtk_container_set_border_width (GTK_CONTAINER(tree), 5);

    gtk_scrolled_window_add_with_viewport (GTK_SCROLLED_WINDOW(scrolled_win), tree);

    gtk_widget_show (window);
    gtk_main();
  }
  // In a nonterminal
  void defaultIn (Node node)
  {
    GtkWidget *subtree = gtk_tree_new();
    GtkWidget *subtree_item = gtk_tree_item_new_with_label(node.type_name());
    gtk_widget_show (subtree_item);

    gtk_tree_append (GTK_TREE(stack.top()), subtree_item);
    gtk_tree_item_set_subtree(GTK_TREE_ITEM(subtree_item), subtree);

    gtk_tree_item_expand (GTK_TREE_ITEM(subtree_item));

    stack.push(subtree);
  }

  // Out a nonterminal
  void defaultOut (Node node)
  {
    stack.pop();
  }

  // A terminal
  void defaultCase (Node node)
  {
    Token token = node.cast<Token>();
    GtkWidget *item = gtk_tree_item_new_with_label (token.getText().c_str());
    gtk_widget_show (item);
    gtk_tree_append(GTK_TREE(stack.top()), item);
  }

  void caseTEOF(TEOF node)
  {
  }

private:
  stack<GtkWidget *> stack;
};

#endif

class TextPrinter : public ReversedDepthFirstAdapter {
  enum codes {
    ESC = 27
  };

  enum style {
    NORMAL = 0,
    BOLD = 1,
    UNDERSCORE = 4,
    BLINK = 5,
    CONCEALED = 8
  };

  enum fg_color {
    FG_BLACK = 30,
    FG_RED = 31,
    FG_GREEN = 32,
    FG_YELLOW = 33,
    FG_BLUE = 34,
    FG_MAGENTA = 35,
    FG_CYAN = 36,
    FG_WHITE = 37
  };

  enum bg_color {
    BG_BLACK = 40,
    BG_RED = 41,
    BG_GREEN = 42,
    BG_YELLOW = 43,
    BG_BLUE = 44,
    BG_MAGENTA = 45,
    BG_CYAN = 46,
    BG_WHITE = 47
  };


public:
  TextPrinter () : last(false), color(false)
  {
  }

  void outStart (Start node)
  {
    cout << treeColor() << "\n" << output.substr(3, output.size() - 3) << "\n" << resetColor();
  }

  void defaultIn (Node node)
  {
    if ( last )
        indentchar.push('`');
    else
        indentchar.push('|');

    indent = indent + "   ";
    last = true;
  }

  void defaultOut (Node node)
  {
    indent = indent.substr(0, indent.size() - 3);
    indent = indent.substr(0, indent.size() - 1) + indentchar.top();
    indentchar.pop();
    output = indent + "- " + setColor (NORMAL, FG_GREEN, BG_BLACK) + node.type_name() + treeColor() + "\n" + output;
    indent = indent.substr(0, indent.size() - 1) + "|";
  }

  void defaultCase (Node node)
  {
    if ( last ) indent = indent.substr(0, indent.size() - 1) + "`";

    output = indent + "- " + setColor(NORMAL, FG_RED, BG_BLACK) + 
        node.cast<Token>().getText() + treeColor() +"\n" + output;

    indent = indent.substr(0, indent.size() - 1) + "|";

    last = false;
  }

  string setColor (style style, fg_color fgColor, bg_color bgColor)
  {
    ostringstream out;

    if ( color )
        out << (char)ESC << "[" << (int)style << ";" << (int)fgColor << "m";

    return out.str();
  }

  void caseTEOF (TEOF node)
  {
    last = false;
  }

  string resetColor ()
  {
    if ( color )
        return (char)ESC + string("[0m");
    else
        return "";
  }

  string treeColor ()
  {
    return setColor (NORMAL, FG_BLACK, BG_BLACK);
  }

  void setColor (bool b)
  {
    color = b;
  }

private:
  string indent, output;
  bool last;
  stack<char> indentchar;
  bool color;
};

int main (int argc, char *argv[])
{
  if ( argc == 2 && (strcmp (argv[1], "-help") == 0 || strcmp (argv[1], "-h") == 0) ) {
      cout << "Usage:" << endl;
      cout << "  " << argv[0] << " [" << "-ansi]" << endl;
#ifdef USE_GTK
      cout << "  " << argv[0] << " -gtk" << endl;
#endif
      return 0;
  }

  try {
      Lexer l(new StreamReader (cin.rdbuf()), true);

      Parser p(&l);

      Start s = p.parse();

#ifdef USE_GTK
      if ( argc == 2 && strcmp (argv[1], "-gtk") == 0 ) {
          gtk_init(&argc, &argv);
          GtkPrinter printer;
          s.apply(printer);
      } else
#endif
      {
          TextPrinter printer;
          if ( argc == 2 && strcmp(argv[1], "-ansi") == 0 )
              printer.setColor(true);

          s.apply(printer);
      }

  } catch (const ParserException& e) {
      cerr << "Caught general parser exception: " << e.getMessage() << endl;
  } catch (const LexerException& e) {
      cerr << "Caught lexer exception: [" << e.getLine() << "," << e.getPos() << "]: " << e.getMessage() << endl;
  } catch (const Exception& e) {
      cerr << "Caught general exception: " << e.getMessage() << endl;
  } catch (...) {
      cerr << "Caught unspecified exception!!!" << endl;
  }

  return 0;
}
$ end output

$ end template

