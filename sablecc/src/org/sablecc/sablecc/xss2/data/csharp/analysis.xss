$ template make_analysis()
$
$ output $basedir + '/analysis.cs'
/* This file was generated by SableCC (http://www.sablecc.org/). */

using System;
using System.Collections;
using $package.node;

namespace $package.analysis {

$ // Generate the Analysis class 

public interface Analysis : Switch
{
    Object GetIn(Node node);
    void SetIn(Node node, Object inobj);
    Object GetOut(Node node);
    void SetOut(Node node, Object outobj);

    void CaseStart(Start node);
$ foreach {//alt}
    void Case@ename(@ename node);
$ end

$ foreach {//token}
    void Case@ename(@ename node);
$ end
    void CaseEOF(EOF node);
}

$ // Generate the AnalysisAdapter class 

public class AnalysisAdapter : Analysis
{
    private Hashtable inhash;
    private Hashtable outhash;

    public virtual Object GetIn(Node node)
    {
        if(inhash == null)
        {
            return null;
        }

        return inhash[node];
    }

    public virtual void SetIn(Node node, Object inobj)
    {
        if(this.inhash == null)
        {
            this.inhash = new Hashtable(1);
        }

        if(inobj != null)
        {
            this.inhash[node] = inobj;
        }
        else
        {
            this.inhash.Remove(node);
        }
    }
    public virtual Object GetOut(Node node)
    {
        if(outhash == null)
        {
            return null;
        }

        return outhash[node];
    }

    public virtual void SetOut(Node node, Object outobj)
    {
        if(this.outhash == null)
        {
            this.outhash = new Hashtable(1);
        }

        if(outobj != null)
        {
            this.outhash[node] = outobj;
        }
        else
        {
            this.outhash.Remove(node);
        }
    }
    public virtual void CaseStart(Start node)
    {
        DefaultCase(node);
    }

$ foreach {//alt}
    public virtual void Case@ename(@ename node)
    {
        DefaultCase(node);
    }
$ end

$ foreach {//token}
    public virtual void Case@ename(@ename node)
    {
        DefaultCase(node);
    }
$ end

    public virtual void CaseEOF(EOF node)
    {
        DefaultCase(node);
    }

    public virtual void DefaultCase(Node node)
    {
    }
}

$ // Generate the DepthFirstAdapter class 

public class DepthFirstAdapter : AnalysisAdapter
{
    public virtual void InStart(Start node)
    {
        DefaultIn(node);
    }

    public virtual void OutStart(Start node)
    {
        DefaultOut(node);
    }

    public virtual void DefaultIn(Node node)
    {
    }

    public virtual void DefaultOut(Node node)
    {
    }

    public override void CaseStart(Start node)
    {
        InStart(node);
        node.Get${/parser/prods/prod/@ename}().Apply(this);
        node.GetEOF().Apply(this);
        OutStart(node);
    }

$ foreach {//alt}
    public virtual void In@ename(@ename node)
    {
        DefaultIn(node);
    }

    public virtual void Out@ename(@ename node)
    {
        DefaultOut(node);
    }

    public override void Case@ename(@ename node)
    {
        In@ename(node);
$   foreach {elem}
$     if @is_list
        {
            Object[] temp = new Object[node.Get@ename().Count];
            node.Get@ename().CopyTo(temp, 0);
            for(int i = 0; i < temp.Length; i++)
            {
                ((@etype) temp[i]).Apply(this);
            }
        }
$     else
        if(node.Get@ename() != null)
        {
            node.Get@ename().Apply(this);
        }
$     end
$   end foreach
        Out@ename(node);
    }
$ end foreach
}

$ // Generate the ReversedDepthFirstAdapter class 

public class ReversedDepthFirstAdapter : AnalysisAdapter
{
    public virtual void InStart(Start node)
    {
        DefaultIn(node);
    }

    public virtual void OutStart(Start node)
    {
        DefaultOut(node);
    }

    public virtual void DefaultIn(Node node)
    {
    }

    public virtual void DefaultOut(Node node)
    {
    }

    public override void CaseStart(Start node)
    {
        InStart(node);
        node.GetEOF().Apply(this);
        node.Get${/parser/prods/prod/@ename}().Apply(this);
        OutStart(node);
    }

$ foreach {//alt}
    public virtual void In@ename(@ename node)
    {
        DefaultIn(node);
    }

    public virtual void Out@ename(@ename node)
    {
        DefaultOut(node);
    }

    public override void Case@ename(@ename node)
    {
        In@ename(node);
$   foreach {reverse(elem)}
$     if @is_list
        {
            Object[] temp = new Object[node.Get@ename().Count];
            node.Get@ename().CopyTo(temp, 0);
            for(int i = temp.Length - 1; i >= 0; i--)
            {
                ((@etype) temp[i]).Apply(this);
            }
        }
$     else
        if(node.Get@ename() != null)
        {
            node.Get@ename().Apply(this);
        }
$     end
$   end foreach
        Out@ename(node);
    }
$ end foreach
}
} // namespace $package.analysis
$ end output
$ end template

