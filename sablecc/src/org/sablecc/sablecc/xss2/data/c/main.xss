$ param dest_dir = '.', target_build

$ param package = @package
$ param libname = {translate($package, '.', '_')}
$ param basedir = $dest_dir

$ // One can override basic memory allocation functions used inside the parser, given same signature
$ param malloc = 'malloc'
$ param free = 'free'
$ param realloc = 'realloc'

$ param inline_keyword = 'inline'
$ param nodes_alloc = '250'
$ param tokens_alloc = '4000'
$ param parser_initial_stack_size = '32'
$ param lexer_backbuffer_chunk_size = '256'
$ param lexer_initial_tokenbuf_size = '64'
$ param user_properties_include = ''

$ param omit_long_errors = '' //|YES, omit long error messages
$ param omit_ignored_token_values = '' //|YES, omit ignored token values at lexer level
$ param omit_node_names = '' //|YES, omit node name strings
$ param omit_token_defaults = '' //|YES, omit token defaults, uses memory instead
$ param omit_alloca_for_malloc = ''//|YES, use malloc instead of alloca
$ param release_discarded_nodes = ''//|YES, release discarded nodes

$ param parser_inline = ''//|YES, inline parser rules

$ param input_encoding = 'byteischar' //| /*utf8*/

$ // TOKENS allocaton (memory management)
$ // "cached" for token memory savings in most cases (but slowness)
$ // released at parser destruct
$ // "fast token alloc" for fast token allocation at parser
$ // (not memory saving, just append data without frees, released at pool destruct)
$ // "malloc" - average malloc, requires you to destroy every node manually
$ // "chained" malloc + double chained pointered, release at pool destruct
$ // or when you destroy a node
$ // "fastmalloc" our own implementation of malloc, chained and semi-pooled
$ param token_alloc = 'fast' // | /*cached|malloc|chained|fastmalloc*/
$ // "pooled node alloc" for fast and pooled node allocations at parser
$ param node_alloc = 'pooled' // | /*malloc|chained*/
$
$ // NOTE: currently only 'fast' token_alloc and 'pooled' node_alloc is implemented.
$ // Also only 'byteischar' input_encoding is implemented.

$ param prefix = ''
$ param ucprefix = {translate($prefix, 'abcdefghijklmnopqrstuvxyz', 'ABCDEFGHIJKLMNOPQRSTUVXYZ')}
$ param prefix_macro = $ucprefix, prefix_type = $prefix, prefix_function = $prefix, prefix_nodetype = $prefix + 'n'


$ set baseprod = {//prod/@ename}

$ output $dest_dir + '/' + $libname + '.h'
#ifndef __${$libname}_h__
#define __${$libname}_h__

/**
  * Parser generated by SableCC C backend.
  * For SableCC see http://www.sablecc.org/
  * For alternative generation backends see http://www.mare.ee/indrek/sablecc/
  * Parser generation options:
  *     Prefix is (prefix): $prefix
  *     Inline keyword is (inline_keyword): $inline_keyword
  *     Extend free nodes in a pool by (nodes_alloc): $nodes_alloc
  *     Token space to allocate in chunks of (tokens_alloc): $tokens_alloc
  *     Lexer backbuffer chunk size (lexer_backbuffer_chunk_size): $lexer_backbuffer_chunk_size
  *     Initial lexer token buffer size (lexer_initial_tokenbuf_size) $lexer_initial_tokenbuf_size
  *     Initial parser stack size (parser_initial_stack_size): $parser_initial_stack_size
  *     Use for malloc (malloc): $malloc
  *     Use for realloc (realloc): $realloc
  *     Use for free (free): $free
$ if {$user_properties_include != ''}
  *     User type data structude definition is in (user_properties_include): $user_properties_include
  *     Derived type data structude type: struct ${concat($prefix_type,'user_properties')}
$ end if
  *     Omit long parser error messages (omit_long_errors): [-if {$omit_long_errors = ''}-]NO[-else-]YES[-end-]
  *     Omit ignored token values (omit_ignored_token_values): [-if {$omit_ignored_token_values = ''}-]NO[-else-]YES[-end-]
  *     Omit node name strings (omit_node_names): [-if {$omit_node_names = ''}-]NO[-else-]YES[-end-]
  *     Omit token default values (omit_token_defaults): [-if {$omit_token_defaults = ''}-]NO[-else-]YES[-end-]
  *     Use malloc instead of alloca in reverse traversal (omit_alloca_for_malloc): [-if {$omit_alloca_for_malloc = ''}-]NO[-else-]YES[-end-]
  *     Inline parser production rules (parser_inline): [-if {$parser_inline = ''}-]NO[-else-]YES[-end-]
  *     Release discarded tokens at parse time (release_discarded_nodes): [-if {$release_discarded_nodes = ''}-]NO[-else-]YES[-end-]
  */

#include <stdio.h>

$ if {$user_properties_include != ''}
#include "$user_properties_include"
$ end if

#ifdef __cplusplus
extern "C" {
#endif

/* in case of multithreaded application call this first, it initializes the internal static data structures */
extern void ${$prefix_function}init ();

$ set pools = 'struct ' + $prefix_type + 'pool'
$pools;
extern $pools *${$prefix_function}pool_create ();
extern void ${$prefix_function}pool_destroy ($pools *pool);

enum ${$prefix_type}node_type
{
$ foreach  {//token}
  ${$prefix_nodetype}@ename,
$ end foreach
  ${$prefix_nodetype}TEOF,
$ foreach {//alt}
  ${$prefix_nodetype}@ename,
$ end foreach
  ${$prefix_nodetype}Start
};

#define ${$prefix_macro}FIRST_TOKEN ${$prefix_nodetype}${//token/@ename}
#define ${$prefix_macro}LAST_TOKEN ${$prefix_nodetype}TEOF
#define ${$prefix_macro}FIRST_PRODUCTION ${$prefix_nodetype}${//alt/@ename}
#define ${$prefix_macro}LAST_PRODUCTION ${$prefix_nodetype}Start

$ set nodes = 'struct ' + $prefix_type + 'node'
$nodes;

$nodes
{
  enum ${$prefix_type}node_type type;
  union {
    struct {
      const char *value;
      int len;
      int line;
      int pos;
    } token;
    $nodes *node_array[${rules/@maxargs}];
$ foreach {//alt}
    struct {
$   foreach {elem}
$     if @is_list
      struct {
        $nodes *first;
      } l@ename;
$     else
      $nodes *@ename;
$     end if
$   end foreach
    } @ename;
$ end foreach
    struct {
      $nodes *$baseprod;
      $nodes *TEOF;
    } Start;
  } c;
  $nodes *next;    /* for a linked list */
$ if {$user_properties_include != ''}
  struct ${concat($prefix_type,'user_properties')} props;
$ end if
};

$ set subnodes = 'struct ' + $prefix_type + 'subnode_data_str'
$subnodes
{
  int count;
  int *is_list;
};
extern $subnodes ${$prefix_function}subnode_data[${count(prods/prod/alt) + 1}];

#define ${$prefix_macro}PRODUCTION_ELEM_COUNT(type) (${$prefix_function}subnode_data[(type) - ${$prefix_macro}FIRST_PRODUCTION].count)
#define ${$prefix_macro}PRODUCTION_ELEM_IS_LIST(type) (${$prefix_function}subnode_data[(type) - ${$prefix_macro}FIRST_PRODUCTION].is_list)

#define ${$prefix_macro}ELEM(type,name) c.type.name

#define ${$prefix_macro}NODE_TYPE(n) ((n)->type)
#define ${$prefix_macro}NODE_IS_TOKEN(n) (${$prefix_macro}NODE_TYPE(n) < ${$prefix_macro}FIRST_PRODUCTION)
#define ${$prefix_macro}NODE_IS_PRODUCTION(n) (${$prefix_macro}NODE_TYPE(n) >= ${$prefix_macro}FIRST_PRODUCTION)

#define ${$prefix_macro}TOKEN_LINE(t) (t)->c.token.line
#define ${$prefix_macro}TOKEN_POS(t) (t)->c.token.pos
#define ${$prefix_macro}TOKEN_LEN(t) (t)->c.token.len
#define ${$prefix_macro}TOKEN_VAL(t) (t)->c.token.value

$ set lexers = 'struct ' + $prefix_type + 'lexer'
$ set parsers = 'struct ' + $prefix_type + 'parser'
$lexers;
$parsers;

extern $lexers * ${$prefix_function}lexer_create_from_path($pools *pool, const char *path);
extern $lexers * ${$prefix_function}lexer_create_from_file($pools *pool, FILE *in);
extern $lexers * ${$prefix_function}lexer_create_from_string($pools *pool, const char *str, int len);

typedef $nodes * (*${$prefix_type}lexer_get_t)(void *);
extern $nodes *${$prefix_function}lexer_get ($lexers *lexer);
extern const char * ${$prefix_function}lexer_get_error ($lexers *lexer);
extern void ${$prefix_function}lexer_destroy ($lexers *lexer);

extern $parsers *${$prefix_function}parser_create($pools *pool);
extern $nodes *${$prefix_function}parser_parse ($parsers *parser, ${$prefix_type}lexer_get_t get_fn, void *lexer_data);
extern const char * ${$prefix_function}parser_get_error ($parsers *parser);
extern void ${$prefix_function}parser_destroy ($parsers *parser);

extern $nodes *${$prefix_function}node_alloc ($pools *pool, enum ${$prefix_type}node_type type);
extern $nodes *${$prefix_function}node_alloc_token ($pools *pool, enum ${$prefix_type}node_type type, const char *value, int len);
extern $nodes *${$prefix_function}node_alloc_dirty ($pools *pool);
extern $nodes *${$prefix_function}node_clone ($pools *pool, $nodes *what);
extern const char * ${$prefix_function}node_name (const $nodes *node);

extern void ${$prefix_function}node_list_append ($nodes **list, $nodes *node);
extern void ${$prefix_function}node_list_remove ($nodes **list, $nodes *node);

extern void ${$prefix_function}node_free ($pools *pools, $nodes *node);

/* use this for building tree walkers */
#define ${$prefix_macro}PRODUCTION_ITERATE(n,expression) \
{\
  $nodes **_i; \
  int _c = ${$prefix_function}subnode_data[n->type - ${$prefix_macro}FIRST_PRODUCTION].count; \
  _i = n->c.node_array; \
  while ( _c-- ) { \
    $nodes *iterator = *_i++; \
    while (iterator) { \
      { expression; } \
      iterator = iterator->next; \
    } \
  } \
}

#define ${$prefix_macro}REVERSE_PRODUCTION_ITERATE(n,expression) \
{\
  $nodes **_i; \
  int _c = ${$prefix_function}subnode_data[n->type - ${$prefix_macro}FIRST_PRODUCTION].count; \
  _i = n->c.node_array + _c; \
  while ( _c-- ) { \
    $nodes *iterator = *--_i; \
    if ( iterator->next ) { \
      int _n = 0; \
      $nodes *_i = iterator; \
      while (_i) { _n++; _i = _i->next; } \
$ if {$omit_alloca_for_malloc = ''}
      $nodes **_buf = alloca(sizeof($nodes*)*_n); \
$ else
      $nodes **_buf = malloc(sizeof($nodes*)*_n); \
$ end if
      _i = iterator; \
      while (_i) { *_buf++ = _i; _i = _i->next; } \
      do { iterator = *--_buf; { expression; } } while (--_n); \
$ if {$omit_alloca_for_malloc != ''}
      free (_buf); \
$ end if
    } else { \
      { expression; } \
    } \
  } \
}

/* safer variant of previous function */
#define ${$prefix_macro}NODE_ITERATE(n,expression) \
  if (${$prefix_macro}NODE_IS_PRODUCTION(n)) ${$prefix_macro}PRODUCTION_ITERATE(n,expression)

#define ${$prefix_macro}REVERSE_NODE_ITERATE(n,expression) \
  if (${$prefix_macro}NODE_IS_PRODUCTION(n)) ${$prefix_macro}REVERSE_PRODUCTION_ITERATE(n,expression)

#ifdef __cplusplus
}; /* extern "C" */
#endif

#endif /* !__${$libname}_h__ */
$ end output

$ output $dest_dir + '/' + $libname + '.c'
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "$libname.h"

$ include 'nodes.xss'
$ include 'lexer.xss'
$ include 'parser.xss'

void ${$prefix_function}init ()
{
  if ( !lexer_initialized ) lexer_init();
  if ( !parser_initialized ) parser_init();
}

$ end output

$ if $target_build
$   include 'utils.xss'
$ end if

