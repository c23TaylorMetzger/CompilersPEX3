$ template make_prods()
$
$ // the first proudction name that goes into Start 
$ set baseprod={//prod/@ename}
$
$ output $basedir + '/prods.cs'
/* This file was generated by SableCC (http://www.sablecc.org/). */

using System;
using System.Collections;
using System.Text;

using  $package.analysis;

namespace $package.node {

$ // generate all production classes 
$ foreach {//prod}
public abstract class @ename : Node
{
}

$ end

$ // generate all alternative classes 
$ foreach {//alt}
public sealed class @ename : ${../@ename}
{
$ //   define subnodes 
$   foreach {elem}
$     if @is_list
    private TypedList _@{name}_;
$     else
    private @etype _@{name}_;
$     end
$   end foreach

$ // define default empty constructor 
$   if {elem}
    public @ename ()
    {
$     foreach {elem}
$       if @is_list
        this._@{name}_ = new TypedList(new @{ename}_Cast(this));
$       end
$     end foreach
    }
$   end if

$ // define constructor 
    public @ename (
$   foreach {elem}
$     if @is_list
            IList _@{name}_[-sep ','-]
$     else
            @etype _@{name}_[-sep ','-]
$     end
$   end foreach
    )
    {
$   foreach {elem}
$     if @is_list
        this._@{name}_ = new TypedList(new @{ename}_Cast(this));
        this._@{name}_.Clear();
        this._@{name}_.AddAll(_@{name}_);
$     else
        Set@{ename} (_@{name}_);
$     end
$   end foreach
    }

$ // define clone() 
    public override Object Clone()
    {
        return new @ename (
$   foreach {elem}
$     if @is_list
            CloneList (_@{name}_)[-sep ','-]
$     else
            (@etype)CloneNode (_@{name}_)[-sep ','-]
$     end
$   end foreach
        );
    }

$ // define apply() 
    public override void Apply(Switch sw)
    {
        ((Analysis) sw).Case@ename(this);
    }

$ // define accessors 
$   foreach {elem}
$     if @is_list
    public IList Get@ename ()
    {
        return _@{name}_;
    }

    public void set@{ename} (IList list)
    {
        _@{name}_.Clear();
        _@{name}_.AddAll(list);
    }
$     else
    public @etype Get@ename ()
    {
        return _@{name}_;
    }

    public void Set@ename (@etype node)
    {
        if(_@{name}_ != null)
        {
            _@{name}_.Parent(null);
        }

        if(node != null)
        {
            if(node.Parent() != null)
            {
                node.Parent().RemoveChild(node);
            }

            node.Parent(this);
        }

        _@{name}_ = node;
    }
$     end if
$   end foreach

$ // define ToString() 
    public override string ToString()
    {
        return ""
$   foreach {elem}
            + ToString (_@{name}_)
$   end
        ;
    }

$ // define removeChild() 
    internal override void RemoveChild(Node child)
    {
$   foreach {elem}
$     if @is_list
        if ( _@{name}_.Contains(child) )
        {
            _@{name}_.Remove(child);
            return;
        }
$     else
        if ( _@{name}_ == child )
        {
            _@{name}_ = null;
            return;
        }
$     end
$   end foreach
    }

$ // define replaceChild() 
    internal override void ReplaceChild(Node oldChild, Node newChild)
    {
$   foreach {elem}
$     if @is_list
        for ( int i = 0; i < _@{name}_.Count; i++ )
        {
            Node n = (Node)_@{name}_[i];
            if(n == oldChild)
            {
                if(newChild != null)
                {
                    _@{name}_[i] = newChild;
                    oldChild.Parent(null);
                    return;
                }

                _@{name}_.RemoveAt(i);
                oldChild.Parent(null);
                return;
            }
        }
$     else
        if ( _@{name}_ == oldChild )
        {
            Set@{ename} ((@{etype}) newChild);
            return;
        }
$     end if
$   end foreach
    }

$ // define cast inner classes for any list elements 
$ foreach {elem[@is_list]}
    private class @{ename}_Cast : Cast
    {
        ${../@ename} obj;

        internal @{ename}_Cast (${../@ename} obj)
        {
          this.obj = obj;
        }

        public Object Cast(Object o)
        {
            @etype node = (@etype) o;

            if((node.Parent() != null) &&
                (node.Parent() != obj))
            {
                node.Parent().RemoveChild(node);
            }

            if((node.Parent() == null) ||
                (node.Parent() != obj))
            {
                node.Parent(obj);
            }

            return node;
        }

        public Object UnCast(Object o)
        {
            @etype node = (@etype) o;
            node.Parent(null);
            return node;
        }
    }
$   end foreach
}
$ end foreach

$ // generate Start class 
public sealed class Start : Node
{
    private $baseprod _base_;
    private EOF _eof_;

    public Start()
    {
    }

    public Start(
        $baseprod _base_,
        EOF _eof_)
    {
        Set$baseprod(_base_);
        SetEOF(_eof_);
    }

    public override Object Clone()
    {
        return new Start(
            ($baseprod) CloneNode(_base_),
            (EOF) CloneNode(_eof_));
    }

    public override void Apply(Switch sw)
    {
        ((Analysis) sw).CaseStart(this);
    }

    public $baseprod Get$baseprod()
    {
        return _base_;
    }
    public void Set$baseprod($baseprod node)
    {
        if(_base_ != null)
        {
            _base_.Parent(null);
        }

        if(node != null)
        {
            if(node.Parent() != null)
            {
                node.Parent().RemoveChild(node);
            }

            node.Parent(this);
        }

        _base_ = node;
    }

    public EOF GetEOF()
    {
        return _eof_;
    }
    public void SetEOF(EOF node)
    {
        if(_eof_ != null)
        {
            _eof_.Parent(null);
        }

        if(node != null)
        {
            if(node.Parent() != null)
            {
                node.Parent().RemoveChild(node);
            }

            node.Parent(this);
        }

        _eof_ = node;
    }

    internal override void RemoveChild(Node child)
    {
        if(_base_ == child)
        {
            _base_ = null;
            return;
        }

        if(_eof_ == child)
        {
            _eof_ = null;
            return;
        }
    }
    internal override void ReplaceChild(Node oldChild, Node newChild)
    {
        if(_base_ == oldChild)
        {
            Set$baseprod(($baseprod) newChild);
            return;
        }

        if(_eof_ == oldChild)
        {
            SetEOF((EOF) newChild);
            return;
        }
    }

    public override string ToString()
    {
        return "" +
            ToString(_base_) +
            ToString(_eof_);
    }
}
}
$ end output
$ end template

