$ template make_parser()

module type PARSER = sig
(* Module [Parser]: SableCC-generated parser. *)
(* This file was generated by SableCC (http://www.sablecc.org/). *)

  open Lexer

  exception Parser_Error of string

  type t

  val create : Lexer.t -> t
(* Return a new Parser for the given Parser. *)
  val parse : t -> Nodes.node
(* Return a parse tree from the given Lexer. *)

  val ignored_tokens : t -> Nodes.node -> (Tokens.token list)
(* Returns a list of ignored tokens for the given AST node. *)

end


module Parserdat = struct

let action_table = [|
$ foreach {parser_data/action_table/row}
  [|
$   foreach {action}
    [| @from; @action; @to |];
$   end foreach
  |];
$ end foreach
|]

let goto_table = [|
$ foreach {parser_data/goto_table/row}
  [|
$   foreach {goto}
    [| @from; @to |];
$   end foreach
  |];
$ end foreach
|]

let error_messages = [|
$ foreach {parser_data/error_messages/msg}
"${sablecc:string2escaped_unicode(string(.))}" ;
$  end foreach
|]

let errors = [|
$       foreach {parser_data/errors/i}
${.} ;
$       end foreach
|]

end

module Parser = struct

open Parserdat
open Nodes

exception Parser_Error of string

type node_or_list = Node of node | List of node list
type state = int * node_or_list list

(* debugging function *)
let string_of_node_or_list d =
  match d with Node n -> ("n: "^string_of_node n)
  | List l -> ("l: ["^String.concat ", " (List.map string_of_node l)^"]")

type t = { 
    lexer : Lexer.t;
    ignored_tokens : (Nodes.node, (Tokens.token list)) Hashtbl.t;
    stack : state Stack.t;
    mutable last_shift : int;
    mutable last_token : Tokens.token;
    action0 : int; action1 : int;
}

let create lx = { 
  lexer = lx; 
  ignored_tokens = Hashtbl.create 200;
  stack = Stack.create ();
  last_shift = -1; last_token = Tokens.Null_Token;
  action0 = 0; action1 = 0;
}

let ignored_tokens t = Hashtbl.find t.ignored_tokens

(* stack api *)
let state t = fst (Stack.top t.stack)

let push t num_state list_node = Stack.push (num_state, list_node) t.stack

let pop t = snd (Stack.pop t.stack)

let index t = match t with
| Tokens.Null_Token -> failwith "can't index null"
| Tokens.T (_, bt) -> match bt with
$ foreach {//token}
  | Tokens.@ename [-if {not(@text)}-]_ [-end if-]-> [-if {@parser_index}-]@parser_index[-else-]-1[-end if-]
$ end foreach
  | Tokens.EOF -> ${tokens/eof/@parser_index};

exception Bail

let go_to t index = 
  let low = ref 1 
  and high = ref ((Array.length Parserdat.goto_table.(index)) - 1)
  and value = ref Parserdat.goto_table.(index).(0).(1) in
  try while low <= high do
    let middle = (!low + !high) / 2 in
    if (state t) < Parserdat.goto_table.(index).(middle).(0) then
      high := middle - 1
    else if (state t) > Parserdat.goto_table.(index).(middle).(0) then
      low := middle + 1
    else
      begin
        value := Parserdat.goto_table.(index).(middle).(1);
        raise Bail
      end
  done; !value
  with Bail -> !value


$ foreach {rules/rule}
let new@index t =
  let node_list = ref [ ] in begin
$   foreach {action}
$   choose
$     when {@cmd='POP'}
        let @result = pop t in
$     end
$     when {@cmd='FETCHLIST'}
        let @result = ref (match (List.nth @from @index) with List l -> l |  _ -> failwith "type error") in
$     end
$     when {@cmd='FETCHNODE'}
        let @result = (match (List.nth @from @index) with Node q -> q | _ -> failwith "type error") in
$     end
$     when {@cmd='ADDNODE'}
        if @node <> Nodes.Null_Node then
        @tolist := !@tolist @@ [ @node ];
$     end
$     when {@cmd='ADDLIST'}
        if !@fromlist <> [] then
            @tolist := !@tolist @@ !@fromlist
        else ();
$     end
$     when {@cmd='MAKELIST'}
        let @result = ref [] in
$     end
$     when {@cmd='MAKENODE'}
        let @result = (Nodes.P (Nodes.[-set t=@etype-][-foreach {//alt[@ename=$t]}-]${../@ename}[-end foreach-] (Nodes.@etype (Nodes.a_[-foreach {//alt[@ename=$t]}-]${@name}[-if {count(../alt) != 1}-]_${../@name}[-end if-][-end foreach-]
$       foreach {arg}
$           if @null
              (Nodes.Null_Node)
$           else
              [-if {@is_list}-]![-end if-]${.}
$           end
$       end foreach
                                 )))) in
$     end
$     when {@cmd='RETURNNODE'}
$       if @null
        node_list := !node_list @@ [(Node Nodes.Null_Node)];
$       else
        node_list := !node_list @@ [(Node @node)];
$       end
$     end
$     when {@cmd='RETURNLIST'}
        node_list := !node_list @@ [(List !@list)];
$     end
$   end choose
$   end foreach
        ()
  end; !node_list
$ end foreach

exception Successful_Parse of node

let parse t = 
  push t 0 [];
  try while true do
    let ign = ref [] in begin
      while index (Lexer.peek t.lexer) == -1 do
        ign := !ign @@ [Lexer.next t.lexer];
      done;
      if !ign <> [] then Hashtbl.add t.ignored_tokens (Nodes.T (Lexer.peek t.lexer)) !ign
    end;

    t.last_token <- Lexer.peek t.lexer;

    let index = index (Lexer.peek t.lexer)
    and action0 = ref Parserdat.action_table.(state t).(0).(1)
    and action1 = ref Parserdat.action_table.(state t).(0).(2)
    and low = ref 1
    and high = ref ((Array.length Parserdat.action_table.(state t)) - 1) in
    begin try while !low <= !high do
      let middle = ((!low + !high) / 2) in

      if index < Parserdat.action_table.(state t).(middle).(0) then
        high := middle - 1
      else if index > Parserdat.action_table.(state t).(middle).(0) then
        low := middle + 1
      else
        begin
          action0 := Parserdat.action_table.(state t).(middle).(1);
          action1 := Parserdat.action_table.(state t).(middle).(2);
          raise Bail;
        end
    done
    with Bail -> (); end;

    match !action0 with
    | 0 (* SHIFT *) -> begin
        push t !action1 [Node (Nodes.T (Lexer.next t.lexer))];
        t.last_shift <- !action1
        end
    | 1 (* REDUCE *) -> begin
        match !action1 with
$ foreach {rules/rule}
        | @index -> push t (go_to t @leftside) (new@index t)
$ end foreach
        | _ -> failwith "bad action1";
            end
    | 2 (* ACCEPT *) -> 
        let node2 = Lexer.next t.lexer and
            node1 = match List.nth (pop t) 0 with Node Nodes.P n -> n | _ -> failwith "type error" in
        raise (Successful_Parse (Nodes.Start (node1, node2)))
    | 3 (* ERROR *) -> 
        raise (Parser_Error (let p = (match t.last_token with Tokens.T (p, _) -> p | Tokens.Null_Token -> failwith "type error") in
        ((Lexer.id t.lexer)^" "^(Tokens.getText t.last_token) ^
         (Tokens.string_of_linepos p) ^
         Parserdat.error_messages.(errors.(!action1)))));
    | _ -> failwith "bad choice";
  done; failwith "exited infinite loop?"
  with Successful_Parse p -> p
end

$ end template
