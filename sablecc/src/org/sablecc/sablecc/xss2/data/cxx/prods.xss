$ template make_prods()
$
$ set baseprod = {//prod/@ename}
$
$ // Generate the prod.h file 
$ output $incdir + '/prod.h'
/* This file was generated by SableCC (http://www.sablecc.org/). */

#ifndef __${$namespace}__prod_hh__
#define __${$namespace}__prod_hh__

namespace $namespace {

template <class T> class List;

$ foreach {//prod}
class @ename : public Node {
public:
  inline @ename () : Node () { }

  static const _TypeInfo type_info;

  inline @ename clone () const { return Node::clone().unsafe_cast<@ename>(); }

  inline void replaceBy (@ename node) { Node::replaceBy (node); }

protected:
  inline @ename (_GenericNode *obj) : Node(obj) { }

private:
  void replaceBy (Node node);
};
$ end foreach

$ foreach {//alt}
class @ename : public ${../@ename} {
protected:
  inline @ename (_GenericNode *obj) : ${../@ename} (obj) { }

public:
  inline @ename () : ${../@ename}() { }

$   if {elem}
  static inline @ename make () { return initProd (&type_info); }
$   end

  static inline @ename make (
$   foreach {elem}
$     if @is_list
      List<@etype>& _@{name}_[-sep ','-]
$     else
      @etype _@{name}_[-sep ','-]
$     end
$   end foreach
  )
  {
    void *args[] = {
$   foreach {elem}
$     if @is_list
        &getListGuts(_@{name}_)[-sep ','-]
$     else
        &_@{name}_[-sep ','-]
$     end
$   end foreach
    };
    return initProd (&type_info, args);
  }

  static const _TypeInfo type_info;

  inline @ename clone () const { return Node::clone().unsafe_cast<@ename>(); }

  inline void replaceBy (@ename node) { Node::replaceBy (node); }

$   foreach {elem}
$     if @is_list
  inline List<@etype>& get@ename () { return reinterpret_cast<List<@etype>& >(getChildList(${position()-1})); }
$     else
  inline @etype get@ename () { return getChildNode(${position()-1}).unsafe_cast<@etype>(); }
  inline void set@ename (@etype _@{name}_) { setChildNode (${position()-1}, _@{name}_); }
$     end if
$   end foreach

private:
  void replaceBy (${../@ename} node);
};
$ end foreach

class Start : public Node {
protected:
  Start (_GenericNode *obj) : Node(obj) { }

public:
  inline Start () : Node () { };

  static const _TypeInfo type_info;

  static inline Start make () { return initProd(&type_info); }
  static inline Start make ($baseprod start, TEOF eof)
  {
    void *args[] = { &start, &eof };
    return initProd (&type_info, args);
  }

  inline $baseprod get$baseprod () { return getChildNode (0).unsafe_cast<$baseprod>(); }
  inline void set$baseprod($baseprod node) { setChildNode(0, node); }
  inline TEOF getTEOF() { return getChildNode(1).unsafe_cast<TEOF>(); }
  inline void setTEOF (TEOF node) { setChildNode(1, node); }

  inline Start clone () const { return Node::clone().unsafe_cast<Start>(); }

  inline void replaceBy (Start node) { Node::replaceBy (node); }

private:
  void replaceBy (Node node);
};

} // namespace $namespace {

#endif // !__${$namespace}__prod_hh__
$ end output

$ end template
