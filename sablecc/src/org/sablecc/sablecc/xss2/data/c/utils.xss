$ output $dest_dir + '/test_lexer.c'
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "$libname.h"

int main (int argc, char *argv[])
{
  $pools *pool = ${$prefix_function}pool_create();
  $lexers *lexer = ${$prefix_function}lexer_create_from_file(pool, stdin);
  while (1)
    {
      $nodes *node = ${$prefix_function}lexer_get (lexer);
      if ( !node )
        {
          printf ("ERROR: %s\n", ${$prefix_function}lexer_get_error (lexer));
          return 1;
        }
      if ( ${$prefix_macro}NODE_TYPE(node) == ${$prefix_nodetype}TEOF ) break;
      printf ("(%d;%d): %s = '%s'\n", ${$prefix_macro}TOKEN_LINE(node), ${$prefix_macro}TOKEN_POS (node), ${$prefix_function}node_name(node), ${$prefix_macro}TOKEN_VAL(node));
    }
  ${$prefix_function}lexer_destroy (lexer);
  ${$prefix_function}pool_destroy (pool);
  return 0;
}
$ end output

$ output $dest_dir + '/test_parser.c'
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "$libname.h"

static char *append (char *buf, const char *str)
{
  if ( !str ) return buf;
  if ( !buf )
    {
      buf = malloc (strlen(str) + 1);
      buf[0] = 0;
    }
  else
    {
      buf = realloc (buf, strlen(buf) + strlen(str) + 1);
    }
  strcat (buf, str);
  return buf;
}

static char *output = NULL;
static char *indent = NULL;
static char *indentchar = NULL;
static int last = 0;

extern int tc;

static void walk_tree ($nodes *node)
{
  if ( ${$prefix_macro}NODE_IS_TOKEN(node) )
    {
      /* this is defaultCase for tokens */
      if ( ${$prefix_macro}NODE_TYPE(node) != ${$prefix_nodetype}TEOF )
        {
          if ( last )
            {
              indent[strlen(indent)-1] = 0;
              indent = append (indent, "`");
            }
          char *tail = output;
          output = append (0, indent);
          output = append (output, "- ");
          output = append (output, ${$prefix_macro}TOKEN_VAL(node));
          output = append (output, "\n");
          output = append (output, tail);
          free (tail);
          indent[strlen(indent)-1] = 0;
          indent = append (indent, "|");
        }
      last = 0;
      return;
    }

  /* this is defaultIn */
  if ( last )
      indentchar = append (indentchar, "`");
  else
      indentchar = append (indentchar, "|");
  indent = append (indent, "   ");
  last = 1;

  /* this is defaultCase */
  ${$prefix_macro}REVERSE_PRODUCTION_ITERATE(node, walk_tree(iterator));

  /* this is defaultOut */
  if ( ${$prefix_macro}NODE_TYPE(node) == ${$prefix_nodetype}Start )
    {
      /* the end */
      printf ("%s", output);
      if ( output ) free (output);
      if ( indent ) free (indent);
      if ( indentchar ) free (indentchar);
    }
  else
    {
      indent[strlen(indent)-4] = 0;
      indent = append(indent, &indentchar[strlen(indentchar)-1]);
      indentchar[strlen(indentchar)-1] = 0;
      char *tail = output;
      output = append (0, indent);
      output = append (output, "- ");
      output = append (output, ${$prefix_function}node_name(node));
      output = append (output, "\n");
      output = append (output, tail);
      free (tail);
      indent[strlen(indent)-1] = 0;
      indent = append (indent, "|");
    }
}

int main(int argc, char *argv[])
{
  $pools *pool = ${$prefix_function}pool_create();
  $lexers *lexer = ${$prefix_function}lexer_create_from_file(pool, stdin);
  $parsers *parser = ${$prefix_function}parser_create (pool);

  $nodes *node = ${$prefix_function}parser_parse (parser, (${$prefix_function}lexer_get_t)${$prefix_function}lexer_get, lexer);
  if ( !node )
    {
      const char *parser_error = ${$prefix_function}parser_get_error (parser);
      const char *lexer_error = ${$prefix_function}lexer_get_error (lexer);
      if ( parser_error )
        {
          printf ("%s\n", parser_error);
        }
      else if ( lexer_error )
        {
          printf ("%s\n", lexer_error);
        }
      else
        {
          printf ("unknown error\n");
        }
      return -1;
    }

  walk_tree (node);

  ${$prefix_function}parser_destroy (parser);
  ${$prefix_function}lexer_destroy (lexer);
  ${$prefix_function}pool_destroy (pool);

  return 0;
}
$ end output

$ output $dest_dir + '/Makefile'
# Makefile generated by SableCC (http://www.sablecc.org/) c backend

CFLAGS ?= -Wall -O2 -g

all: test_lexer test_parser

test_lexer: $libname.o test_lexer.o
	$$(CC) $libname.o test_lexer.o -o test_lexer

test_parser: $libname.o test_parser.o
	$$(CC) $libname.o test_parser.o -o test_parser

clean:
	rm -f $libname.o test_lexer.o test_parser.o test_lexer test_parser .depend

depend:
	$$(CC) -MM $libname.c test_lexer.c test_parser.c > .depend

-include .depend
$ end output

