$ template make_tokens()
$
$ // Generate the token.h file 
$ output $incdir + '/token.h'
/* This file was generated by SableCC (http://www.sablecc.org/). */

#ifndef __${$namespace}__token_hh__
#define __${$namespace}__token_hh__

namespace $namespace {

class Token : public Node {
protected:
  inline Token(_GenericNode *obj) : Node(obj) { }
  friend class Lexer;

public:
  inline Token() : Node() { }

  inline const std::string& getText () const { return ptr()->text; }
  inline int getLine () const { return ptr()->line; }
  inline int getPos () const { return ptr()->pos; }

  inline void setText (const std::string& text)
  {
    if ( ptr()->type_info->token_is_mutable )
        ptr()->text = text;
    else
        throw Exception("Trying to set immutable token text");
  }

  inline void setLine (int line) { ptr()->line = line; }
  inline void setPos (int pos) { ptr()->pos = pos; }

  inline int getIndex () const { return ptr()->type_info->token_index; }

  static const _TypeInfo type_info;

  inline Token clone () const { return Node::clone().unsafe_cast<Token>(); }

  inline void replaceBy (Token node) { Node::replaceBy (node); }

protected:
  static Token make (const _TypeInfo *type_info, int line, int pos, const std::string& text)
  { return _GenericNode::initToken (type_info, line, pos, text); }

  inline void unsafeSetText(const std::string& text)
  { ptr()->text = text; }

private:
  void replaceBy (Node node); // hide it
};

class TEOF : public Token {
public:
  static inline TEOF make () { return make(0, 0); }

  static inline TEOF make (int line, int pos)
  { return Token::make(&type_info, line, pos, "").unsafe_cast<TEOF>(); }

  static const _TypeInfo type_info;

  inline TEOF clone () const { return Node::clone().unsafe_cast<TEOF>(); }

private:
  void setText (const std::string& text); // { } // Get error at compile time
};

$ foreach {//token[not(@text)]}
class @ename : public Token {
public:
  static inline @ename make (const std::string& text) { return make(text, 0, 0); }
  static inline @ename make (const std::string& text, int line, int pos)
  { return Token::make(&type_info, line, pos, text).unsafe_cast<@ename>(); }

  inline void setText (const std::string& text) // Safe to set in variable token, no safety needed
  { unsafeSetText (text); }

  static const _TypeInfo type_info;

  inline @ename clone () const { return Node::clone().unsafe_cast<@ename>(); }

  inline void replaceBy (@ename node) { Node::replaceBy (node); }

private:
  void replaceBy (Token node);
};

$ end foreach

$ foreach {//token[@text]}
class @ename : public Token {
public:
  static inline @ename make () { return make(0, 0); }
  static inline @ename make (int line, int pos)
  { return Token::make(&type_info, line, pos, "${sablecc:string2escaped_unicode(@text)}").unsafe_cast<@ename>(); }

  static const _TypeInfo type_info;

  inline @ename clone () const { return Node::clone().unsafe_cast<@ename>(); }

  inline void replaceBy (@ename node) { Node::replaceBy (node); }

private:
  void setText (const std::string& text); // Get error at compile time
  void replaceBy (Token node);
};

$ end foreach

} // namespace $namespace {

#endif // !__${$namespace}__token_hh__
$ end output

$ end template

